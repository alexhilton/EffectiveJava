
    <span style="font-size:18px;">&nbsp; 1. about naming coventions<br />&nbsp;&nbsp;&nbsp; a. All gtk functions or classes(structures) are started with &quot;gtk&quot; or &quot;Gtk&quot; as prefixes. For instance,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>gtk_widget_destroy, GtkLabel, GtkWidget</em>. All glib functions or classese are prefixed with g, for example<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>g_signal_connect, g_ascii_strcasecmp, G_OBJECT, g_object_set, g_object_get</em><br />&nbsp;&nbsp;&nbsp; b. The operations for each classes was prefixed by class name. for example,<em> gtk_window_new,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gtk_button_new_with_label. GtkWindow, GtkLabel</em>.<br />&nbsp;&nbsp;&nbsp; c. All returning types and arguments are pointers to classes. For example, <em>GtkWidget *gtk_window_new(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gtk_window_set_title( GtkWindow *window, gchar *str );</em><br />&nbsp;&nbsp;&nbsp; d. All constructor of each classes return the pointer to GtkWidget.<br />&nbsp;&nbsp;&nbsp; e. You can covert types using macros. <em>GtkWidget *window; GtkWindow *window = GTK_WINDOW( window )</em>;<br />&nbsp;&nbsp;&nbsp; f. About signal connecting function, it takes pointer to <em>G_OBJECT</em> only, the final argument gpointer is<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the data you wanna pass into event handling function.<br />&nbsp;&nbsp;&nbsp; g. Some event handling function should look like this:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>gboolean event_happened( GtkWidget *widget, GdkEvent *event, gpointer data )</em>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the first arg widget is the widget which received the signal, event is the event and<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pointer is the data you want to pass.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Of course, you can use any other form of event handler, like:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>void event_handle( GtkWidget *widget, gpointer data )</em>;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; This event handler is much more popular than others<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <em>void event_emitted( GtkWidget *widget1, GtkWidget *widget2 );</em><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the arguments are pointers. Since you can cast a pointer to any other<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type, so you can replace GtkWidget with any other kind widget you like. Generally, First arg: widget1 is<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the one from which signals are emitted. It is also the widget to which you connect signal. The second<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; argument of event handler: widget2, also can be casted to other pointers you like. It is passed from<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; final argument of g_signal_connect.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sometimes, your handlers must operate more than one widgets. To solve the problem, you can use a structure<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; which holds all the necessary widgets. You can pass a pointer to such structure into your handler. E.G.<br /></span><textarea readonly name="code" class="cpp">    typedef struct {
      GtkWindow *window;
      GtkLabel *label;
      GtkButton *button;
    } Data;</textarea><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; You can connect signal and handler this way:<br /><textarea readonly name="code" class="cpp">    g_signal_connect( G_OBJECT( button ), &quot;clicked&quot;, G_CALLBACK( button_clicked ),
        (gpointer) &amp;data );</textarea><br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; The handler should look like this:<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<em>&nbsp; void button_clicked( GtkButton *button, Data *data );</em><br />&nbsp;&nbsp;&nbsp; h.For some operations there are more than one function. We get overloading here. But C does not <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; support overloading explictly. We solve the problem by adding suffixes to functions indicating<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; overloading. e.g.: <em>gtk_button_new(), gtk_button_new_with_label( const char *label ),<br /></em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gtk_button_new_with_mnemonic( const char *mnemonic ). They have the same purpose ---- to create <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a new button. Such overloading is quite popular in GTK+.<br />&nbsp;&nbsp;&nbsp; i. Once you have add some widgets to some containers, you cannot add it to other containers any more.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; That's why we have to new a label after adding it to a vbox. Adding a widget to a container is make<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the container parent of widget. When releasing the widgets, the child will be released if the parent<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is being freed. Problem occurs when releasing widgets if you add a widgets to more than one container.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; It could be released twice which is a fatal error. As a result, you can never add one widget to more <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; than one containers.<br />&nbsp;&nbsp;&nbsp; j. There are some internal event handler functions such as destroy -- gtk_widget_destroy. So you can <br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connect them directly to destroy(gtk_main_quit), gtk_widget_destroy. It is the same to write it by<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yourself.<br />&nbsp;&nbsp;&nbsp; k. Many times, some events have happened, though you have not handled that. A font button, for instance,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; would keep its last font after being clicked. No matter whether you handle the signal 'font_set', it<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; would be there until next click. In fact, in your handler, you do nothing but retrieve the current<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; also last font from the button and set the font to some widgets. Therefore, it is the same business<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to retrieve the font when we are about to use it.<br />&nbsp; 2. Tricks about widgets<br />&nbsp;&nbsp;&nbsp; 1. GtkFileChooser, GtkFileChooserDialog, GtkFileChooserButton<br />&nbsp;&nbsp; &nbsp;when you use those widgets, you should handle signal &quot;file_set&quot; rather than others. &quot;file_set&quot; is the<br />&nbsp;&nbsp; &nbsp;signal emitted when user do a change of file chooser, i.e. select a file, select another file.<br />&nbsp;&nbsp; &nbsp;Signal &quot;selection_changed&quot; will be emitted either when user do a change or when a function change<br />&nbsp;&nbsp; &nbsp;the current path. We should use &quot;selection_changed&quot; to monitor file chooser's change. While &quot;file_set&quot;<br />&nbsp;&nbsp; &nbsp;is for detecting a file has been selected.<br />&nbsp;&nbsp;&nbsp; 2. GtkWindow<br />&nbsp;&nbsp; &nbsp;If you want to add asking dialog before closing, you should catch signal &quot;delete_event&quot;. And the handler's<br />&nbsp;&nbsp; &nbsp;prototype should look like this: gboolean before_exit( GtkWidget *, GdkEvent *, gpointer );<br />&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; returning FALSE if you don't quit, else return TRUE to quit.<br />&nbsp;&nbsp;&nbsp; 3. GtkHBox, GtkVBox<br />&nbsp;&nbsp; &nbsp;To keep your widgets look homogenous, you have to pack all of them onto boxes. If you pack a hbox and<br />&nbsp;&nbsp; &nbsp;a check button onto a vbox, the result is unbalanced. So you'd better arrange all your widgets onto<br />&nbsp;&nbsp; &nbsp;boxes.<br />&nbsp;&nbsp;&nbsp; 4. GtkLabel<br />&nbsp;&nbsp; &nbsp;In order to arrange some widgets onto right place, you can use some labels with empty text as a <br />&nbsp;&nbsp; &nbsp;placeholder. You want to arrange a button called &quot;Exit&quot;, for instance, on the right-down cornor<br />&nbsp;&nbsp; &nbsp;of the window, The easiest way to achieve that is place a label unpon button and a label left to<br />&nbsp;&nbsp; &nbsp;the button.<br />&nbsp;&nbsp;&nbsp; 5. GtkFontButton, GtkColorButton, GtkFileChooserButton, and alike.<br />&nbsp;&nbsp; &nbsp;They are buttons, right. But they are special buttons. To realize their true mission, you cannot<br />&nbsp;&nbsp; &nbsp;treat them as buttons. So you should handle the signal 'font_set', 'color_set' or 'file_set' instead<br />&nbsp;&nbsp; &nbsp;of 'clicked'.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When you are using GtkFileChooserButton, you'd better use event 'selection_change', although it will be<br />&nbsp;&nbsp; &nbsp;emitted when setting its properties. The event 'selection_changed' will be emitted when you change a <br />&nbsp;&nbsp; &nbsp;selection -- that is when you click the button, select another directory or file. Event 'file_set',<br />&nbsp;&nbsp; &nbsp;however, will only be emitted when you click &quot;Others&quot;, opening chooser dialog, selecting a file and clicking<br />&nbsp;&nbsp; &nbsp;&quot;OK&quot; in dialog. So, if you connect event 'file_set' for it, when you click the folders in the button's list,<br />&nbsp;&nbsp; &nbsp;nothing would change. Example: explorerlist.c<br />&nbsp;&nbsp;&nbsp; 6. GtkToggleButton, GtkRadioButton, GtkCheckButton<br />&nbsp;&nbsp; &nbsp;You don't have to write handlers for signal 'toggled'. You can test whether it is active (selected)<br />&nbsp;&nbsp; &nbsp;when using the option. If you write a handler, you have to test whether it is active, too, in order to<br />&nbsp;&nbsp; &nbsp;set some flag indicating an option.<br />&nbsp;&nbsp;&nbsp; 7. GtkDialog.<br />&nbsp;&nbsp; &nbsp;Dialog is like a window which can hold many things. You can add basic widgets like labels, buttons. <br />&nbsp;&nbsp; &nbsp;In addition, you can add GtkAssistant, progress bar, window on it, too. We are happy to say the dialog's<br />&nbsp;&nbsp; &nbsp;constructor again:<br /><textarea readonly name="code" class="cpp">      GtkWidget *gtk_dialog_new_with_buttons( const char *title, GtkWindow *parent,
      GtkDialogFlag flag, const char *label_button1, int response_button1,
      const char *label_button2, int response_button2, ..., NULL );</textarea>&nbsp;&nbsp;&nbsp; You can use labels from stock like <em>GTK_STOCK_YES, GTK_STOCK_NO, GTK_STOCK_CANCEL, GTK_STOCK_APPLY</em>, etc.<br />&nbsp;&nbsp; &nbsp;You can also use some responses predefined by GTK+ like: <em>GTK_RESPONSE_YES, GTK_RESPONSE_NO,<br />&nbsp;&nbsp; &nbsp;GTK_RESPONSE_CANCEL, GTK_RESPONSE_APPLY</em>, etc. There is a container vbox in dialog structure, so<br />&nbsp;&nbsp; &nbsp;you can add anything onto it.<br />&nbsp;&nbsp; &nbsp;We use the responses of dialog to handle different clicks on buttons, say, returning GTK_RESPONSE_YES means<br />&nbsp;&nbsp; &nbsp;button 'Yes' has been clicked, returning GTK_RESPONSE_CANCEL means button 'cancel' has been clicked. A<br />&nbsp;&nbsp; &nbsp;typical one is like this:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <textarea readonly name="code" class="cpp">&nbsp;&nbsp;&nbsp; int result = gtk_dialog_run( GTK_DIALOG( dialog ) );
&nbsp;&nbsp; &nbsp;&nbsp; if ( result == GTK_RESPONSE_YES ) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* do something */
&nbsp;&nbsp; &nbsp;&nbsp; } else if ( result == GTK_RESPONSE_NO ) {
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; /* do something */
&nbsp;&nbsp; &nbsp;&nbsp; }
</textarea>&nbsp;&nbsp;&nbsp; In general, we would destroy the dialog after clicking one of its buttons by adding:<br />&nbsp;&nbsp; &nbsp;&nbsp; gtk_widget_destory( dialog );<br />&nbsp;&nbsp; &nbsp;after handling return values.<br />&nbsp;&nbsp; &nbsp;At some other times, we want to keep the dialog, because we are not done yet. Some properties panel dialog,<br />&nbsp;&nbsp; &nbsp;for example, have three buttons, Cancel, OK and Apply. Clicking Cancel will quit the dialog and do nothing.<br />&nbsp;&nbsp; &nbsp;Click OK will apply current settings and quit the dialog. Clicking Apply, however, will apply the settings,<br />&nbsp;&nbsp; &nbsp;but don't quit the dialog. For those dialogs, we should put gtk_widget_destroy after GTK_RESPONSE_CANCEL and<br />&nbsp;&nbsp; &nbsp;GTK_RESPONSE_OK. But for Apply we should use some other tricks --- we have to keep the dialog and get return<br />&nbsp;&nbsp; &nbsp;values, so a while loop is necessary. We usually do like this:<br />&nbsp;&nbsp;&nbsp;&nbsp; <textarea readonly name="code" class="cpp">      while ( 1 ) {
        result = gtk_dialog_run( GTK_DIALOG( dialog ) );
        if ( result == GTK_RESPONSE_CANCEL ) {
          /* do something */
          gtk_widget_destroy( dialog );
          break;
        } else if (    result == GTK_RESPONSE_OK ) {
          /* do something */
          gtk_widget_destroy( dialog );
          break;
        } else if ( result == GTK_RESPONSE_APPLY ) {
          /* do something */
        }
      }</textarea>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; We will never leave the dialog unitl 'Cancel' or 'OK' is clicked.<br />&nbsp;&nbsp;&nbsp; 8. The event handler for signal 'delete-event' of window must be like this:<br />&nbsp;&nbsp; &nbsp;static gboolean window_close( GtkWindow *window, GdkEvent *event, gpointer data );<br />
