
    <span style="font-size:18px;">Summary about mutlti-threading in C and Java<br />&nbsp; 1. If the main thread terminates, then the whole program dies, too. So if you<br />&nbsp; want to run some tasks in a sub thread, you must guarantee that sub thread<br /></span><p><span style="font-size:18px;">&nbsp; terminates before main thread.</span></p><p><span style="font-size:18px;"><br /></span></p><span style="font-size:18px;">&nbsp; 2. If you want to execute some task in a separate thread and wait until its<br />&nbsp; termination, you should use pthread_join rather than condition and mutex.<br />&nbsp; pthread_join is like waitpid, it suspend the calling thread until another<br />&nbsp; thread terminates and you can retrieve thread's termination status through<br /></span><p><span style="font-size:18px;">&nbsp; pthread_join which is much more difficult to do using condition and mutex.</span></p><p><span style="font-size:18px;"><br /></span></p><span style="font-size:18px;">&nbsp; 3. <em>PTHREAD_MUTEX_INITIALIZER</em> and <em>PTHREAD_COND_INITIALIZER</em> are implemented as<br />&nbsp; macros. So when you use them incorrectly, you will get very confucious<br />&nbsp; compiling error messages. For example,<br />&nbsp; &nbsp;&nbsp; &nbsp;...<br />&nbsp;&nbsp; &nbsp;static pthread_mutex_t lock;<br />&nbsp;&nbsp; &nbsp;...<br />&nbsp;&nbsp;&nbsp; 43&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; lock = <em>PTHREAD_MUTEX_INITIALIZER</em>;<br />&nbsp;&nbsp; &nbsp;...<br />&nbsp; If you compile, you will get:<br />&nbsp; &nbsp;&nbsp; &nbsp;43: error: expected expression before token '{'<br />&nbsp; The most weird thing is that there is no such token '{'. We can imagine that<br />&nbsp; <em>PTHREAD_MUTEX_INITIALIZER</em> is implemented as macro. <br />&nbsp; In addition we have two ways to initialize mutex and conditions, <br />&nbsp;&nbsp;&nbsp; 1. initialize them when declaring them.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><textarea readonly name="code" class="cpp">        static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
        static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</textarea><br />&nbsp;&nbsp;&nbsp; 2. use initializing functions after declaration.<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <textarea readonly name="code" class="cpp">        pthread_mutex_init( &amp;lock, NULL );
        pthread_cond_init( &amp;cond, NULL );</textarea><br /><span style="font-size:18px;">&nbsp; 4. When you wait a condition, you must lock its mutex, when you signal a<br />&nbsp; condition, you MUST NOT lock the mutex. MAKE sure you change the condition<br /></span><p><span style="font-size:18px;">&nbsp; before signaling.</span></p><p><span style="font-size:18px;"><br /></span></p><span style="font-size:18px;">&nbsp; 5. Thread has its local stack frame, just like a function. Any local<br />&nbsp; variable(auto variables, declared in the thread) becomes invalid when thread<br />&nbsp; exits. So you should NEVER return a auto variable or put an auto variable<br />&nbsp; into global data strutures.<br /></span><br />
